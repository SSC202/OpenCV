# OpenCV 9_边缘检测

图像的边缘指的是图像中像素灰度值突然发生变化的区域，如果将图像的每一行像素和每一列像素都描述成一个关于灰度值的函数，那么图像的边缘对应在灰度值函数中是函数值突然变大的区域。函数值的变化趋势可以用函数的导数描述。当函数值突然变大时，导数也必然会变大，而函数值变化较为平缓区域，导数值也比较小，因此可以通过寻找导数值较大的区域去寻找函数中突然变化的区域，进而确定图像中的边缘位置。

由于图像是离散的信号，可以用临近的两个像素差值来表示像素灰度值函数的导数。
$$
\frac{df(x,y)}{dx}=f(x,y)-f(x-1,y)
$$

这种对x轴方向求导方式对应滤波器为
$$
\left [ 
\begin{matrix}
1 & -1
\end{matrix}
\right ]
$$
同时，对y轴求导方式对应滤波器为
$$
\left[
\begin{matrix}
1 & -1
\end{matrix}
\right]^T
$$
这种求导方式的结果接近于两个像素中间位置的梯度，但是在两个相邻像素中间没有像素。
如图
$$
\frac{df(x,y)}{dx} = \frac{f(x+1,y)-f(x-1,y)}{2}
$$
此时在x方向对应滤波器为
$$
\left [
    \begin{matrix}
    0.5 & 0 & -0.5
    \end{matrix}
\right ]
$$
在y方向上滤波器为
$$
\left [
    \begin{matrix}
    0.5 & 0 & -0.5
    \end{matrix}
\right ]^T
$$
亦可通过以下滤波器计算45°方向的梯度。
$$
XY = \left |
    \begin{matrix}
    1 & 0 \\
    0 & -1
    \end{matrix}
\right |
\quad
YX = \left |
    \begin{matrix}
    0 & 1 \\
    -1 & 0
    \end{matrix}
\right |
$$
为了在图像中同时表示出这两种边缘信息，需要将计算的结果求取绝对值。
```c++
//绝对值函数
void cv::convertScaleAbs(InputArray  src,
                         OutputArray  dst,
                         double  alpha = 1,
                         double  beta = 0 
                        );
```
>src：输入矩阵。
>
>dst：计算绝对值后输入矩阵。
>
>alpha：缩放因子，默认参数为只求取绝对值不进行缩放。
>
>beta：在原始数据上添加的偏值，默认参数表示不增加偏值。

$$
dst(I) = |src(I)*\alpha+\beta|
$$

图像的边缘包含X方向的边缘和Y方向的边缘，因此分别求取两个方向的边缘后，对两个方向的边缘求取并集就是整幅图像的边缘，即将图像两个方向边缘结果相加得到整幅图像的边缘信息。

## 拉普拉斯算子

边缘检测算子都具有方向性，因此需要分别求取X方向的边缘和Y方向的边缘，之后将两个方向的边缘综合得到图像的整体边缘。Laplacian算子具有各方向同性的特点，能够对任意方向的边缘进行提取，具有无方向性的优点，因此使用Laplacian算子提取边缘不需要分别检测X方向的边缘和Y方向的边缘，只需要一次边缘检测即可。Laplacian算子是一种二阶导数算子，对噪声比较敏感，因此常需要配合高斯滤波一起使用。

$$
\Delta f = \frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2}
$$
```c++
void cv::Laplacian(InputArray  src,
                   OutputArray  dst,
                   int  ddepth,
                   int  ksize = 1,
                   double  scale = 1,
                   double  delta = 0,
                   int  borderType = BORDER_DEFAULT
                  );
```
>src：输入原图像，可以是灰度图像或彩色图像。
>
>dst：输出图像，与输入图像src具有相同的尺寸和通道数
>
>ddepth：输出图像的数据类型（深度），根据输入图像的数据类型不同拥有不同的取值范围，当赋值为-1时，输出图像的数据类型自动选择。
>
>ksize：滤波器的大小，必须为正奇数。
>
>scale：对导数计算结果进行缩放的缩放因子，默认系数为1，表示不进行缩放。
>
>delta：偏值，在计算结果中加上偏值。
>
>borderType：像素外推法选择标志，默认参数为BORDER_DEFAULT，表示不包含边界值倒序填充。

第三个参数为输出图像的数据类型，这里需要注意由于提取边缘信息时有可能会出现负数，因此不要使用CV_8U数据类型的输出图像，否则会使得图像边缘提取不准确。

第四个参数是滤波器尺寸的大小，必须是正奇数，当该参数的值大于1时，该函数通过Sobel算子计算出图像X方向和Y方向的二阶导数，将两个方向的导数求和得到Laplacian算子。

## Canny 算法

Canny算法不容易受到噪声的影响，能够识别图像中的弱边缘和强边缘，并结合强弱边缘的位置关系，综合给出图像整体的边缘信息。Canny边缘检测算法是目前最优越的边缘检测算法之一。

1. 使用高斯滤波平滑图像，减少图像中噪声。

一般使用高斯滤波器 G。
$$
G = \frac{1}{139}
\left [
    \begin{matrix}
    2 & 4 & 5 & 4 & 2 \\
    4 & 9 & 12 & 9 & 4 \\
    5 & 12 & 15 & 12 & 5 \\
    4 & 9 & 12 & 9 & 4 \\
    2 & 4 & 5 & 4 & 2 \\
    \end{matrix}
\right ] 
$$

2. 计算图像中每个像素的梯度方向和幅值。首先通过Sobel算子分别检测图像X方向的边缘和Y方向的边缘，随后计算梯度的方向和幅值。

$$
\theta = arctan(\frac{I_y}{I_x})
\\
G = arctan\sqrt{I_x^2 + I_y^2}
$$

3. 应用非极大值抑制算法消除边缘检测带来的杂散响应。首先将当前像素的梯度强度与沿正负梯度方向上的两个像素进行比较，如果当前像素的梯度强度与另外两个像素梯度强度相比最大，则该像素点保留为边缘点，否则该像素点将被抑制。

4. 应用双阈值法划分强边缘和弱边缘。将边缘处的梯度值与两个阈值进行比较，如果某像素的梯度幅值小于较小的阈值，则会被去除掉；如果某像素的梯度幅 值大于较小阈值但小于较大阈值，则将该像素标记为弱边缘；如果某像素的梯度幅值大于较大阈值，则将该像素标记为强边缘。

5. 消除孤立的弱边缘。在弱边缘的8邻域范围寻找强边缘，如果8邻域内存在强边缘，则保留该弱边缘，否则将删除弱边缘，最终输出边缘检测结果。

```c++
void cv::Canny(InputArray  image,
               OutputArray  edges,
               double  threshold1,
               double  threshold2,
               int  apertureSize = 3,
               bool  L2gradient = false 
              );
```

>image：输入图像，必须是CV_8U的单通道或者三通道图像。
>
>edges：输出图像，与输入图像具有相同尺寸的单通道图像，且数据类型为CV_8U。
>
>threshold1：第一个滞后阈值。
>
>threshold2：第二个滞后阈值。
>
>apertureSize：Sobel算子的直径。
>
>L2gradient：计算图像梯度幅值方法的标志

$$
L_1 = |\frac{dI}{dx}|+|\frac{dI}{dy}|

\\

L_2 = \sqrt{(\frac{dI}{dx})^2+(\frac{dI}{dy})^2}
$$

较高的阈值会降低噪声信息对图像提取边缘结果的影响，但是同时也会减少结果中的边缘信息。同时程序中先对图像进行高斯模糊后再进行边缘检测，结果表明高斯模糊在边缘纹理较多的区域能减少边缘检测的结果，但是对纹理较少的区域影响较小。